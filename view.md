####view

####算法基础
* LRU && LFU
  * LRU（最近最少被使用，思想是，最近被访问的数据，未来被访问到的概率高）
    * 实现方法一（链表头插法，被访问到的与链表头交换， 淘汰链表尾的数据。 O(n)扫描数据）
    * 实现方法二 （LinkHaskMap: 启用按访问顺序存储，具体实现和上面差不多）  
  * LFU （如果数据过去被访问多次，那么将来被访问的频率也更高）
    * 好难 

####JAVA基础
#####消息中间件
* PULL&Push 模式对比 
  * PULL
      * 优点：服务端不用维护状态， 需要能够多消息进行堆积。
      * 缺点：依赖消费方拉取， 实时性较差（拉取大量， 实时性较差， 拉取小量，QPS压力大）
  * Push
      * 优点： 实时性好，收到消息立即发送
      * 缺点： 服务端需要维护推送状态，server压力较大。  推送端无法感知消费端能力，易对服务端造成消费压力。   

####数据库基础(MySql)
#####大神文章[Link](http://hedengcheng.com/?p=771#_Toc374698308)
#####基础
* 快照读（select）不加锁
* 当前读（update， delete， insert） 
* 一个表最多可有16个索引。最大索引长度是256个字节, 编译是可以改变
* 对于CHAR和VARCHAR列，你可以索引列的前缀。这更快并且比索引整个列需要较少的磁盘空间。（KEY index_name (col_name(length))）
#####锁&隔离级别
* 记录锁（行锁）， X锁，S锁， 
* 隔离级别
  * RC，（read commited）
  * RR，（repeated read）
  * 主要非主键索引或者唯一索引的情况下，普通索引会当前读情况下会产生Gap锁， 
#####问题
* 联合索引
  * MySQL能在多个列上创建索引。一个索引可以由最多15个列组成。一个多重列索引可以认为是包含通过合并(concatenate)索引列值创建的值的一个排序数组。 

####综合
* 服务降级能力
* 缓存失效（周期性触发失效，可以使用随机波动的缓存生效时间）
* 服务治理
  * Hsf 
* Http链接