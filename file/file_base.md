######文件系统之读写基础篇
######文件系统
* 文件系统是操作系统重要组成部分，且我们的好多应用都是依赖直接文件系统，包括数据库、消息中间件 MetaQ、Kafka。

作为应用开发人员，我们经常和文件系统打交道或和构建在文件之上的软件打交道。

开发人员很必要多了解点文件系统，使工作起来更得心应手，也更好知道数据库，中间件的原理。

更多详细基础的介绍，可以参考我前面一篇文章--深入浅出文件系统
######文件系统之读写
######文件描述符
* 对操作系统内核来说，每个打开的文件（网络连接也是一样）都有一个文件描述符。文件描述符是一个正整数。当进程打开或创建一个新文件，内核会向进程返回一个文件描述符。根据前面一篇文章--深入浅出文件系统 的介绍，文件描述符，只在每个进程内有效，不同的进程，可以有相同的文件符。
######基本IO系统函数
* 这里选择了一些我个人认为重要且常见的函数详细解释下，更多详细的信息请通过Linux man命令查看。

基本IO系统函数每次调用，都是一次系统调用，会有上下文切换，都会有一定的开销。

open

用来打开或创建文件一个文件，其行为可以通过参数控制，详细文档可以通过man 2 open来看，open返回的文件描述符一定是当前没有使用的最小的描述符值。默认情况下，一个进程启动时，0、1、2 分别用来表示标准输入流、标准输出流、标准错误流。所以open或其它的系统调用返回的是4

close

关闭一个打开的文件描述符，详细文档通过man 2 close查看。当一个进程终止时，内核自动关闭此进程打开的文件。

read

详细的方法签名

  ssize_t
     read(int fildes, void *buf, size_t nbyte);
默认情况下，read是一个同步方法，调用方必须等待read方法返回。

read方法返回值 ，可能有下面几种情况

read方法返回的值等于其参数len，表示读取len长度的数据
read方法返回的值的大于0且小于len,有部分数据可读，但不是全部，在这网络环境下比较常见
read方法返回0，表示没有数据可读，即EOF
read方法返回为-1 ,表示方法出错
read方法还有可能被阻塞住，可能因为网络数据还没有到达(到达了，但还没有传入到内核了)或磁盘正在读取但还没有全部准备好，触发中断 。

write
详细方法签名

 ssize_t
 write(int fildes, const void *buf, size_t nbyte);
默认情况下，write方法是也是一个同步方法，但write方法只要写入文件系统或写入到socket，就会返回，而不是等待数据真正写入的磁盘或写入到网络的对端才返回。

如果方法调用成功，会向文件符写入nbyte长度的数据(如果是网络，写入的数据长度可能是[0,nbyte])，同时文件的偏移量会更新(如果是磁盘文件)

需要注意，如果socket的output buffer已满，可能没有写完全写入数据，所以要判断，数据是否完全写入。

fsync
把参数文件描述符文件数据写入到磁盘。前面一篇文章--深入浅出文件系统介绍过，文件的数据包括两部分，文件数据、文件的元数据。fsync方法会把文件数据、文件元数据都写入到磁盘。但并不表示数据此时就安全了，因为fsync方法返回时，磁盘驱动程序还有可能没有把数据真正写入到磁盘。

fdatasync
此函数的行为和fsync类似，都是把数据写入到的磁盘，但fdatasync 仅仅是把文件数据写入到磁盘，并不包括文件元数据。因为fdatasync写的数据比fsyc要不，所以性能比fsyc要快。

在一些应用中，要保证数据可靠同时又要性能高，会选择使用fdatasync。

sync

此函数也是把数据同步到磁盘，但是把系统中所有的文件缓存数据都同步到磁盘。可以在bash中执行sync 命令，会等待所有的数据(文件数据、元数据)同步到磁盘，所以执行一次即可，不需要执行多次。至少在Linux系统是这样的。
#####标准IO库
#####缓冲(buffer)
* 根据前一小节的介绍，每个IO调用都是系统调用，开销比较大。为了减少开销，可以减少IO调用的次数，怎么解决呢？缓冲(buffer)、缓冲、还是缓冲，通过缓存就可以减少IO调用的次数，进而提高性能。

一个简单的性能对比测试，测试方法是从/dev/zero从读出105MB数据，同时写入到byte.txt文件

很显示看出，在块缓冲大分别为1字节、1024字节、4096字节时三个值，4096的大小，性能最好。

admin@bkloandecision bkloandecision.d1168.mayibank.net /home/admin/test]
$  time dd bs=1 count=102400K if=/dev/zero of=byte.txt
^@记录了104857600+0 的读入
记录了104857600+0 的写出
104857600字节(105 MB)已复制，138.951 秒，755 kB/秒

real    2m18.952s
user    0m10.632s
sys 2m6.468s

[admin@bkloandecision bkloandecision.d1168.mayibank.net /home/admin/test]
$  time dd bs=1024 count=100K if=/dev/zero of=byte.txt
记录了102400+0 的读入
记录了102400+0 的写出
104857600字节(105 MB)已复制，0.293722 秒，357 MB/秒

real    0m0.317s
user    0m0.010s
sys 0m0.306s

[admin@bkloandecision bkloandecision.d1168.mayibank.net /home/admin/test]
$  time dd bs=4096 count=25K if=/dev/zero of=byte.txt
记录了25600+0 的读入
记录了25600+0 的写出
104857600字节(105 MB)已复制，0.175337 秒，598 MB/秒

real    0m0.198s
user    0m0.004s
sys 0m0.194s

简单解释下图的几行命令

time是Linux自带的统计命令执行时间的工具，dd是一个复制文件的工具，其它详细文档可以分别通过man time 、man dd 查看。
######缓冲(buffer)类型
*  全缓冲
在IO缓冲区已满的情况下，才会触发实际的IO。对于文件系统(磁盘块设备)，一般是使用这种类型。

行缓冲
只有在遇到换行符时，才会触发实际的IO操作。比如常见的终端(Terminal)操作,这也就是为什么在终端上执行命令，为什么要回车之后，命令才开始执行。

无缓冲
标准错误流 （stderr）一般情况是没有缓冲，这样方便有错误，及时输出，方便及时发现问题。

上面三种缓冲类型，都是可以通过setvbuf函数来设置，给不同的文件描述符设置不同的缓冲的类型。
######并发问题
######并发产生的原因
* 当多个进程读同一个文件，没有写操作，所以数据是安全的。但多个进程同时写一个文件，有可能就会造成脏数据。

如果进程1和进程2都对同一个文件操作，假设文件此时的长度为1000，进程1调用lseek，将写的从设置为文件未尾，也就是1000处，还没有来得及写数据，就发生了进程切换，这时候，进程2分配到了CPU,开始运行，调用了 lseek,将写的位置设置为文件未尾，同样是1000处，并且调用write写入了500字节，如果此时内核发生了调度，又使进程1开始运行，进程将从偏移量1000处，开始写入数据。悲剧发生，因为这样就把进程2写的数据给覆盖了，造成了脏数据。



造成脏数据图解

进程1调用lseek准备写数据,还没有写

* 图1 ![](http://i.imgur.com/9zUTjFB.png)
* 进程1刚要写准备写数据，进程1CPU时间片用完，内核发生CPU调度，使用进程1挂起，进程2开始运行写入500字节数据
* 图2 ![](http://i.imgur.com/0S51V3P.png)
* 进程2写完数据且运行一段时间，进程2CPU时间片用完，内核发生CPU调度，使用进程1开始运行，并写入250字节 。这样造成进程2写入的数据已脏。 
* 图3![](http://i.imgur.com/WqERwM4.png)
* 并发造成脏数据本质是是write写数据，先要找到位置从哪开始写，也就是找位置，然后写数据，这是两个操作，但是很不幸，这不是原子操作，所以会有并发问题。

这个问题本质和Java中的i++不是线程安全的原因类似，因为这是两个操作，先读，后写，这两个操作不是原子的。
######怎么保证并发安全
* O_APPEND 标识
也就是说在调用open时，方法参数标识加上O_APPEND，这样可以保证，每次调用write时，都可以保证从文件最未尾位置处，开始写入数据。

应用自己加锁

就是说在每次调用write前，都去抢占一个锁，如果成功，则写入数据，否则重试抢或放弃。
当然这样性能就比较差，后有介绍怎么优化。
