#### JAVA线程

* java线程实现方式
  * 实现runnable接口（无结果返回）
  * 实现callable接口 （可以通过Future获取返回执行结果）
  * 直接继承Thread类（为一个实现runnable接口类的实例） 
  
* Java 创建线程代价
  * 关于时间，创建线程使用是直接向系统申请资源的，这里调用系统函数进行分配资源的话耗时不好说。对操作系统来说,创建一个线程的代价是十分昂贵的, 需要给它分配内存、列入调度,同时在线程切换的时候还要执行内存换页,CPU 的缓存被 清空,切换回来的时候还要重新从内存中读取信息,破坏了数据的局部性
  * 关于资源,Java线程的线程栈所占用的内存是在Java堆外的，所以是不受java程序控制的，只受系统资源限制，默认一个线程的线程栈大小是1M（当让这个可以通过设置-Xss属性设置，但是要注意栈溢出问题），但是，如果每个用户请求都新建线程的话，1024个用户光线程就占用了1个G的内存，如果系统比较大的话，一下子系统资源就不够用了，最后程序就崩溃了。
    
* 线程池 
  * 存在的意义
     * 降低使用线程代价，（节约系统创建线程， 销毁线程的时间）
     * a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。 
     * b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 
     * c. 提供定时执行、定期执行、单线程、并发数控制等功能。
  * 线程池实现
    * 原理
      * 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
      * 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
      * 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
      * 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。  
    * 常用线程池：ExecutorService 是主要的实现类，其中常用的有 :
      Executors.newSingleThreadPool() 之创建一个线程执行任务

    　　newFixedThreadPool() 固定数目线程数

    　　newcachedTheadPool() 使用时才创建线程

   　　 newScheduledThreadPool()

* 参考文档[链接地址](http://www.codeceo.com/article/java-thread-pool-implementation.html)  

#### JAVA多线程同步
##### WHY-同步
  * 因为当我们有多个线程要同时访问一个变量或对象时，如果这些线程中既有读又有写操作时，就会导致变量值或对象的状态出现混乱，从而导致程序异常。举个例子，如果一个银行账户同时被两个线程操作，一个取100块，一个存钱100块。假设账户原本有0块，如果取钱线程和存钱线程同时发生，会出现什么结果呢？取钱不成功，账户余额是100.取钱成功了，账户余额是0.那到底是哪个呢？很难说清楚。因此多线程同步就是要解决这个问题。

##### 同步方式

* 1: synchronized 修饰方法
  * 即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
  * Tips：synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类

* 2: synchronized 修饰代码块
  *   synchronized 修饰的逻辑越少代码执行效率就越高（同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。）


* 3： 使用特殊域变量(Volatile)实现线程同步（该实现可能会有问题-- 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只有确保可见性。）
  * a.volatile关键字为域变量的访问提供了一种免锁机制
  * b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新
  * c.因此每次使用该域就要重新计算，而不是使用寄存器中的值
  * d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 （这点很关键， 它只能提供变量的原子访问，可内存读写可见，但是不能保证操作数据过程的原子）   

* 4: 使用重入锁实现线程同步(ReentrantLock)
  *  ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有：ReentrantLock() : 创建 ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁
 
  * Tips：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用
* （5）使用局部变量实现线程同步
  * threadLocal
   * 使的线程拥有变量私有备份，使用线程私有变量threadLocalMap 进行变量管理（使用Thread）。   