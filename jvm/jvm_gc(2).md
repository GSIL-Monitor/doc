######JVM学习笔记-垃圾回收（二）
######前言
*  上一章讲到垃圾回收前的准备工作，就是通过可达性算法确定堆内或方法区(FULL GC)内哪些数据数据需要被回收，这章讲我们将具体聊聊这些区域的垃圾回收大体是如何实现的。
######垃圾收集算法
######标记-清除算法
* Mark-Sweep算法是最为基础的算法，正如其名，算法包含两个步骤：1.先标记要回收的对象，2.清除标记的对象。实现过程很简单，但是这种算法有2个明显缺点：一是效率问题，标记和清除过程的效率都说不是很高，二是空间问题，清除之后可能产生大量的内存碎片。当程序需要分配大对象时，可能由于获取不到连续的内存空间而出发另一次GC操作。标记-
* 图一 ![](http://i.imgur.com/hrpWwjx.png)
######复制算法
* 为了解决这种效率问题，就出现了“copy”复制算法，它是将内存分成大小相同2个部分，每次只使用其中一块，另一块空闲。当一块空间不足时，就将需要存活的对象复制到另一块内存上，并清理掉本空间内存。这样就不用考虑内存碎片的问题。只要移动堆顶指针，按顺序分配内存即可。虽然提高了效率，但是它的代价就是将可用内存缩小到原来一半。复制执行过程如下图：
* 图2 ![](http://i.imgur.com/lXy0L4t.png)
######标记-整理算法
* 之前阐述了标记-清除算法的弊端，特别是在内存碎片方面上的问题，所以有人提出了“标记-整理算法”，标记过程仍然和之前一样，但后续不是直接对标记对象清理，而是让所有存活对象往一端移动，然后清理掉边界以外的内存。我觉得把它称之为“标记-移动-清理”算法更为合适。以下是此算法执行过程：
* 图3 ![](http://i.imgur.com/lyb6W6Q.png)
* 通过以上描述，我们总结这3中算法的优缺点：
1.标记清除算法：
    优点：a、充分利用内存空间。
    缺点：a、标记与清除的效率比较低。
            b、容易产生空间碎片。
            c、内存分配比较麻烦，需要一个空间列表记录空闲区域。
2.复制算法
    优点：a、没有内存碎片。
            b、内存分配简单，指针顺序移动即可。
            c、效率高
    缺点：a、空间利用率低，可用的空间只有一半。
            b、存活率高的对象会被多次复制，效率变低。
3.标记整理算法
    优点：a、没有内存碎片。
            b、充分利用内存空间。
    缺点：a、效率比起标记清除算法要低。
#####分代收集算法
* 当前的JVM根据对象的存活率，一半将堆划分为新生代和老年代。同时根据各个年代内对象的特点，比如：新生代垃圾收集次数肯定是最高的，每次收集都有大量的对象死去，所以适合效率高的算法，于是选择复制算法。而老年代的对象存活率高，GC次数比较少，为了提高空间利用率，可以使用2种“标记”算法。
    以下，我们可以结合HotSpot学习JVM的分代策略：
* 图4 ![](http://i.imgur.com/YgiWCUQ.png)
* 这里我们主要研究一下新生代的YoungGC策略，由于新生代使用的是复制算法，但是复制算法需要1：1的空闲空间，所以将新生代分为eden和survivor，survivor内分为from和to的1：1空间，相互成为彼此的空闲空间。由于每次youngGC后新生代eden区域的对象大多数会被销毁。只保留很小一部分，所以survivor只有很小一部分，eden与survivor默认8：2。当eden空间不足时，对象迁移到survivor，并且在from和to之前复制。达到一定次数后进入老年代（JVM默认15次）。
我们可以结合线上服务器的配置来学习一下。

登录服务器，使用指令ps -aux | grep 'java'可以获取服务器JVM配置：



可见以下参数
-Xms4g 堆内存最小4g
-Xmx4g 堆内存最大4g
-XX:MetaspaceSize=256m 元空间256m（一部分方法区实现）jdk8之前为-XX:PermSize
-XX:MaxMetaspaceSize=256m 元最大空间256m（一部分方法区实现）jdk8之前为-XX:MaxPermSize
-Xmn2g 新生代2g，所以老年代也是2g
-XX:MaxDirectMemorySize=1g  直接内存1g（一部分方法区实现）
-XX:SurvivorRatio=10 新生代eden与survivor为10：1*2
-XX:+UseConcMarkSweepGC  使用老年代并发标记清除(CMS)收集器，记得jdk8老年代默认使用G1收集器？ 

