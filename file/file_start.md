######深入浅出文件系统
######文件系统
* 数据需要存储和检索。进程运行时，数据可以保存在内存中，但内存存储容量有限且价格较贵，当机器意外宕机或重启后，数据就会丢失。磁盘因其长久保存存储数据的特性，且价格相比内存要便宜，所以磁盘用来当作长久存储数据的介质。暂时我们把磁盘当成一个线性序列，对外提供读写数据功能。

文件是进程创建信息的逻辑单元，磁盘上会许多文件，但每个文件都是独立的。

文件是受操作系统管理的，一般认为，操作系统中处理文件的那部分叫文件系统。
######文件系统基本概念
* 文件是一种抽象机制，它对磁盘进行了抽象。

文件就是字节序列，每个I/O设备，包括磁盘、键盘、显示器、甚至网络，都可以抽象成文件，在Unix/Linux系统中，系统中所有的输入输出都是通过调用IO系统调用来完成。

文件是对IO的抽象，就像虚拟存储器是对程序存储的抽象，进程是对一个正在运行程序的抽象。这些都是操作系统重要的抽象。

抽象机制最重要的特性是对管理对象的命名，所以文件有文件名，且文件名要符合一定的规范。
######文件主要操作
* create
read
write
fsync
rename
lseek
上面的操作比较简单，就不是细说，后面会写文章再介绍读文件、写文件、刷新数据这几个重要的操作。如果有兴趣，可以通过man 2 read 命令来查看帮助文档，效果如下
* 图1 ![](http://i.imgur.com/227fCxp.png)
######文件类型
* 可以通过ls -l查看文件类型，主要有下面几种常见的。

普通文件

包括文本文件和二进制文件

目录 
和普通文件相比，目录也存储在介质上，但是目录不存储常规文件，它只是用来组织、管理文件。

proc

proc不存储，所以不占用任何空间，proc使得内核可以生成与系统状态和配置相关的信息，该信息可以由用户和系统内核从普通文件读取，无需专门的工具。

其它更多的文件类型，可以通过man ls 查看，效果如下图
* 图2 ![](http://i.imgur.com/G4GlTDx.png)
* 文件类型一般可以通过后缀来识别，在Windows系统中是这样，但在Unix/Linux中，文件后缀只是一种约定，并不强制，如名为.txt文件，也可以是二进制文件。
######文件属性
* 文件属性包括文件权限信息、创建时间、最后修改时间、最后读取时间、文件大小、文件引用数等信息，这些文件属性也称为文件无数据。
######目录
* 文件系统使用目录将文件组织成一个类似于树的层次系统。实际组织时，将文件相关文件组成一个组，形成目录。由于目录本身也是文件，所以目录还可以包含其他目录，从而形成层次结构。

用目录树组织文件系统时，需要有一种方法确定文件名，常用的方法有二种。

绝对路径

由根目录到文件的路径组成。

相对路径

和当前工作的目录配合使用，想对路径和当前工作目录，可以构造绝对路径，当前工作目录一般是通过Bash启动命令所在的目录，一般程序运行，会通过调用系统调用chdir来设置当前目录为当前工作目录 。

目录主要操作

create

创建目录

delete

删除目录

opendir

打开目录

closedir

关闭目录

readdir

读取目录`

rename

重命名

link

链接操作，可以让一个文件出现在多个目录里，可分为硬连接、软连接。

unlink
是对link的反向操作。

######挂载点(mount point)
* 在系统中，很多文件组成一棵非常大的树，树的根就是根目录。

在通过情况下，并不是所有的文件都在一个磁盘上，文件系统有可能存储在多个磁盘上。

每个磁盘都有自己的文件系统，但在访问文件时，通过统一的操作系统入口，所以磁盘上的文件系统必须挂载到主树上来。其它磁盘文件系统挂载在主树中的目录，就称为挂载点 （mount point）。
######文件系统实现原理
* 文件系统存储在磁盘上，一般磁盘会被划分为多个分区，每个分区可以是一个独立的文件系统。

磁盘的0号扇区为主引导记录(Master Boot Record，MBR)，用来引导计算机。

在MBR的结尾是分区表，该分区表标识了每个分区的起始和结束地址。表中的一个分区被标识为活动分区，在计算机被引导时，BIOS读入并执行MBR。MBR做首先做的是确定活动分区，读入它的第一个块，称为引导块，并执行。

一种常见的文件系统（分区）结构图

* 图三 ![](http://i.imgur.com/YmyZkaW.png)
* Super块

在系统启动时，会读取Super块，它包含了文件系统的所要重要参数。

i-bmap 块

用来管理inode，标识inode是否空闲或被使用了。

d-bmap块

用来管理磁盘块，标识磁盘块是空闲还是被使用了。
#######文件系统实现
* 文件系统一个重要的功能是记录文件使用了哪些磁盘块以及磁盘块的管理，标识磁盘块是否被使用，还是空闲。实现思路有下面几种。

连续分配

把每个文件存储在相邻的磁盘块上。如磁盘块大小2KB,200KB的文件，需要 100个磁盘块，如果磁盘块大小为4KB,刚需要50个磁盘块。

由于每个文件都是从一个新的磁盘块开始的，这样如果一个文件只占了磁盘块大小的一半，那么另一半就被浪费了，没法被别的文件使用，不过连续分配的实现，实现比较简单，只需要记录文件的第一个磁盘块位置和块数，另外读取性能，因为只需要一次寻道，之后不需要导道和旋转延迟。

随着时间推移，磁盘碎片比较严重。因为反复写文件，删除文后，容易在磁盘块上形成空洞。

链表分配

为每个文件构造磁盘块链表，每个块在前面指向文件的下一个磁盘块。

因为是一个链表，所以顺序读取很快，但随机读取很慢，且每个块中，指向下一个磁盘块的指针是要占用空间的，这样导致每个磁盘块能够存储的数据不再是2的整数次幂。

但程序读写文件一般是以2的整数次幂来读写磁盘，这样造成额外的开销，因为读一个块的数据，要读取二个磁盘块。

Inode 节点方案

使用一个特殊的东西来记录每个文件的所使用的磁盘块， 这特殊的东西称为i节点数据结构，其存储了文件 一些属性及文件所使用的到的磁盘块。

i节点只有在对应的文件被打开时，才会存在内存中，这样即使文件系统文件非常多，只要打开的文件不多，就不会占用太多的内存。

文件的元数据和文件数据是分开存储，也就是一个文件有i节点和数据文件这两个属性。

每个存储i节点的磁盘块空间是有限，且一个文件只有一个i节点，那么当一个文件比较大时，怎么解决？大家想没有想起C语言中的指针及指针的指针。

一种解决办法是预留部分数据块，用来存储指向磁盘块的指针，而不是直接直接指向磁盘块。

inode的数据结构中属性di_addr保存块地址数组，大小只有39字节，每个块地址使用3字节来表示，所以di_addr数据只能保存13个元素。


* 图4 ![](http://i.imgur.com/bxYP6ni.png)
* 如图所示其中0-9是直接保存数据块号，数组索引为10保存指向数据块指针的指针，也称为间接索引，数组索引为11指向二级间接块，最后的元素12指向三级间接块。

假设磁盘块大小为1024字节，因为每个指针四字节(32位系统)，inode中的di_addr数组0-9共可以存储10*1024字节，使用单个间接块可以存储(1024/4)*1024 字节，使用二级间接块可以存储(1024/4)*(1024/4)*1024字节，使用三级间接块可 以存储(1024/4)*(1024/4)*(1024/4)*1024字节。

虽然使用间接块，一个inode可以支持很大的文件，但当文件很大时，需要使用了二级、三级间接块，对读取文件造成了额外的开销，因为了多了几次磁盘IO，而磁盘IO是很慢的，相对CPU、内存来说。

#######Unix/Linux文件系统的实现
* Unix/LInux文件系统的实现是采用i节点的方案，文件系统ext2、ext3都是如此，ext4相比前面二种文件 ，做了不少优化，后面有机会再介绍。
#######文件系统与操作系统的协作
* 文件系统是操作系统的一部分，操作系统是相对稳定，但文件系统却是有好多，如ext2、ext3 、ext4 、ZFS 等，那么操作系统是如何兼容这些不同的文件系统，以对外提供统一服务。

Java程序员很容易想到利用多态来实现，对，操作系统也是采用类似的思路。对不同的文件系统，抽象出所有文件系统都支持的、基本的、概念上的数据结构和接口 ，如前文描述的关于文件和目录的基本操作。

这些统一抽象组件，叫着虚拟文件系统(Virtual File System ,VFS),VFS作为系统内核组件，为用户空间程序提供了文件和文件系统相关的接口。

VFS使用得用户可以直接调用write、read 这样的文件系统调用，而不用考虑底层的文件是什么文件系统。

横向地看下它们的关系，如下图所示
* 图5 ![](http://i.imgur.com/pEeiGtr.png)
* 从应用程序角度，自顶向下完整的关系
* 图6 ![](http://i.imgur.com/WFTueQs.png)
* 图中2 表示的是inode的操作

图中3 表示的是VFS对象的操作

logic I/O 和Physical I/O,对Java程序员来说，底层的东西关注比较少，所以重点解释下

logic I/O 
logic I/O 是指发生在文件系统里的读写动作，包括读写命中缓存，直接返回，主要是在文件系统在一层面的。

Physical I/O
Physical I/O是指由文件系统向物理介质发生的读写动作，如磁盘发生的I/O动作，发产生实际的磁盘I/O`。

Oracle里关于SQL性能分析就有logic I/O 和Physical I/O,从上面的解释可以看出，一般情况下，Physical I/O比 logic I/O 慢，甚至是慢一个数量级，因为 Physical I/O会有物理的磁盘I/O。

#######文件系统与磁盘
* 磁盘中最小的寻址单位是扇区，扇区大小一般是2的整数幂，最常见是512字节。

扇区的大小是磁盘的物理属性，扇区是磁盘的基本单元。磁盘无法对比它还小的单元 进行寻址和操作。

因为各种软件的应用场景不同，它们一般会会有自己的最小逻辑寻址单元，对文件系统来说，就是文件系统中的块，块是文件系统的一种抽象，只能基于块来访问文件系统。

虽然物理磁盘最小寻址单元是扇区，但是操作系统内核执行所有的操作都是按文件系统的块大小。由于扇区是磁盘最小的寻址单元，所以块不能比扇区还小，且只能是倍数于扇区。我们暂且叫做文件块。

在文件系统中，空间是以文件系统的块大小为基础，进行分配。文件系统的块一般是512字节、1KB、2KB、4KB、8KB。一般以4kB最为常见。

假设文件系统中的块大小为1KB，一个仅包含1字节文件，也需要一个块。如果一个文件大小为4097字节，则需要的块是5块，因为4块还放下，还多出一个字节，所以需要第五块。

当文件的数据写入到磁盘，会怎么样呢，出于效率的考虑，磁盘存储空间也以固定大小的块分配。我们暂且叫作磁盘块。

假设文件大小为4097，文件块大小为1KB，按上面的计算，需要5个文件，那需要多少磁盘块呢？
如果磁盘分配大小是4KB，则需要2个磁盘块。

那么问题来，如何查看文件系统的文件块和磁盘块大小 。

做一个实验

在一个名为t.txt的文件写一个字母a

$ cat t.txt
a
用ls -al查看其大小，发现却是2字节

$ ls -al t.txt
-rw-r--r-- 1 admin admin 2 12月 26 21:13 t.txt
使用hexdump查看其内容,发现除了字母a外，还多了一个换行符。

$ hexdump -C t.txt
00000000  61 0a                                             |a.|
00000002
使用du 查看其所占用的磁盘大小，发现大小是4KB。

$ du  -h t.txt
4.0K    t.txt

所以此系统的磁盘分配单元大是4KB,而文件系统的块大小，需要麻烦些，但可以看通过下面的命令查看 。

$ sudo /sbin/dumpe2fs  /dev/xvda1 |grep 'Block size'
dumpe2fs 1.41.12 (17-May-2010)
Block size:               4096
所以

$ uname -a
Linux bkloandecision.d1168.mayibank.net 2.6.32-220.23.2.ali878.el6.x86_64 #1 SMP Mon Jan 28 17:12:52 CST 2013 x86_64 x86_64 x86_64 GNU/Linux
系统的文件系统块是4KB,磁盘块也是4KB。

大家有兴趣，可以找台不版本的Linux系统(线下系统)，尝试做下实验。

######进程与文件系统
* 系统中的每一个进程维护了自己所有打开的文件，像根文件系统、当前工作目录、挂载点等。

结构体file_struct 、fs_struct 把VFS和系统的进程紧密联系在一起

数据结构
files_struct

此结构由进程的描述符指中的files指向，进程中都文件相关的信息，都包含在其中
其中fd_array数据指针指向当前进程所有已打开的文件，所谓的文件描述符(句柄)就是文件在fd_array数组中的索引。

fs_struct

此结构由进程描述符中的fs域指向，它包含了文件系统和进程相关的信息，该结构包含了当前进程的当前工作目录和根目录。

关系
每个进程在进程表中都一个记录项,也就是上面提供到fd_array ，记录打开的文件。

内核为所有打开的文件，维护一张文件表，每个文件表都包含，文件标识、当前文件偏移量、指向i节点的指针。

每个打开的文件，都有一个 i节点(其实就是数字)，维护着文件信息。

他们之间的关系，如下图所示

* 图7 ![](http://i.imgur.com/9FWoDnA.png)
* 另外，每个进程能打的文件数量(或网络连接，网络也是文件)是有限，具体的值可以通过如下命令查看
cat /proc/pid/limits,如下面所示。

$ cat  /proc/21339/limits|grep 'files'
Max open files            409600               409600               files
进程的输入输出流
每个进程都有默认的标准输入流、标准输出流、标准错误输出流。进程启动时，就已经设置好了。

标准输入的文件描述符是0

标准输出的文件描述符是1

标准错误的文件描述符是2

######知其然，知其所以然
* 几个常用Linux bash命令和文件系统相关的例子。
重定向
大家在实际使用中，启动一个Java应用或其它命令，经常会使用到重定向。

$ strace cat t.txt > trace.log 
此命令表示执行cat t.txt 命令，将标准输出流重定向到文件trace.log

进程和文件的关系是如图所示
* 图8 ![](http://i.imgur.com/KmIWXM8.png)
* 此命令表示执行cat t.txt 命令，将标准输出流重定向到文件trace.log，同时也把错误流也输出到文件trace.log ，1表示是标准的输出流，2表示标准的错误输出流。

进程和文件的关系是如图所示
* 图9 ![](http://i.imgur.com/2tyFI0k.png) 
* 进程的标准输出流和标准错误输出流都指向了现一个进程文件表里的i节点指向，而这个i节点指针，就是指向文件trace.log。

从上面二张图可以看出，背后的实现原理比较简单，只要fd_array里指针指向同一个文件表里的i节点，就可以实现重定向的功能。事实上操作系统就是通过dup系统调用来实现的, 感兴趣的可以通过man 2 dup查看详细文档。
######硬连接、软连接
* 硬连接 硬连接实现就是通过在目录下新加一个指向i节点目标文件，所以硬件不能跨文件系统。
使用面这个命令来创建一个硬连接。

记录下命令执行前的磁盘和i节点情况。


$ df -h
文件系统          容量  已用  可用 已用%% 挂载点
/dev/xvda1             60G   12G   46G  21% /
tmpfs                 1.9G     0  1.9G   0% /dev/shm

[admin@bkloandecision bkloandecision.d1168.mayibank.net /home/admin/test]
$ df -i
文件系统          Inode  已用(I)  可用(I) 已用(I)%% 挂载点
/dev/xvda1           3932160  252669 3679491    7% /
tmpfs                 490216       1  490215    1% /dev/shm
执行命令

$ ln t.txt hard_t.txt

执行再看下

$ df -h
文件系统          容量  已用  可用 已用%% 挂载点
/dev/xvda1             60G   12G   46G  21% /
tmpfs                 1.9G     0  1.9G   0% /dev/shm

[admin@bkloandecision bkloandecision.d1168.mayibank.net /home/admin/test]
$ df -i
文件系统          Inode  已用(I)  可用(I) 已用(I)%% 挂载点
/dev/xvda1           3932160  252669 3679491    7% /
tmpfs                 490216       1  490215    1% /dev/shm

没有变化，再查看这二个文件的i节点信息，发现他们一样。

$ ls -ial t.txt  hard_t.txt
3294751 -rw-r--r-- 2 admin admin 2 12月 26 21:13 hard_t.txt
3294751 -rw-r--r-- 2 admin admin 2 12月 26 21:13 t.txt

软连接 软连接就是新建立一个文件，此文件内容就是包含目标文件名或目录路径的内容，因为新建了文件，所以会占用 i节点和磁盘空间，但可以跨文件系统。
记录执行前的磁盘和i节点信息。

$ du -sb;df -i
4096    .
文件系统          Inode  已用(I)  可用(I) 已用(I)%% 挂载点
/dev/xvda1  3932160  252669 3679491    7% /
tmpfs                 490216       1  490215    1% /dev/shm
执行命令

$ ln -s t.txt soft-t.txt

查看磁盘和i节点。

$ du -sb;df -i
4101    .
文件系统          Inode  已用(I)  可用(I) 已用(I)%% 挂载点
/dev/xvda1  3932160  252670 3679490    7% /
tmpfs                 490216       1  490215    1% /dev/shm

前后对比发现，目录占用空间由4096变成4101,多了5字节，已用i节点由252669变成252670，可用的数量由3679491减少到3679490

使用ls -al 查看。

$ ls -al
总用量 8
drwxr-xr-x  2 admin admin 4096 12月 26 23:31 .
drwxr-xr-x 22 admin admin 4096 12月 26 22:57 ..
-rw-r--r--  2 admin admin    0 12月 26 23:30 hard_t.txt
lrwxrwxrwx  1 admin admin    5 12月 26 23:31 soft-t.txt -> t.txt
-rw-r--r--  2 admin admin    0 12月 26 23:30 t.txt

soft-t.txt文件大小正好5字节，和前面的数据正好匹配上。

#######参考文档
 

